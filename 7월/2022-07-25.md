# Servlet

## Internet
- #### Network of Network ▶ infrastructure

## TCP/IP
- 데이터 전송 ▶ 패킷(Packet) 단위로 전송됨
### IP : 컴퓨터-컴퓨터 간 데이터(패킷) 전송에 사용되는 프로토콜
- 비신뢰성 : 패킷의 성공적인 전송, 순서가 보장되지 않음
- 비연결성 

### TCP(Transmission control protocol)
- 데이터 전송 제어 프로토콜
- IP 프로토콜을 보완하여 신뢰성 있는 데이터 전송을 가능하게 함

### IP Address
- DNS (Domain Name System, Domain Name Server)
    - 숫자로 구성된 IP 주소를 Domain Name으로 변경하여 사용할 수 있게 해주는 프로세스
    
### Port
- 프로세스에 할당되는 주소, 논리적 숫자
- NIC에 존재하는 여러 개의 프로세스에 각각 고유 Port번호가 할당됨 

### Hypertext
- 사용자의 선택에 따라 관련된 정보 쪽으로 이동할 수 있는 조직화된 정보
- WWW(World Wide Web)의 발명, 발전의 계기

### HTTP
- Hypertext 통신에 적합
- Client-Server 구조 : 하나의 Server(Web Server)가 다수의 Client(보통 Browser)에 service하는 구조

<br><br>

>
### Static Web
: Program 없이 Web Server가 Client에서 요청한 resource를 제공

서버가 가지고 있는 데이터를 일방적으로 제공하기보다는 서버에게 프로그램 실행 후 결과를 요청하는 방식으로 변화함

>
### Dynamic Web
: Server side에 Program이 존재 (Servlet)
- Servlet : 동적으로 HTML Page 생성 
▶ Servlet(Java)와 웹 페이지(HTML, CSS, JS)의 사용 언어가 다르기 때문에 생산성, 유지보수성 🔽

Servlet의 단점을 보완하는 프로그램 개발

>
### JSP
: 생산성을 높이기 위해 사용
▶ 구현은 쉽지만 유지보수성 🔽 

JSP의 단점으로 인해 Servlet으로 다시 돌아오되 다른 방식으로 구현

>
### MVC Pattern
: Layered Architecture 방식의 Servlet
▶ 사용 기법들의 통일성 부족

Pattern들간 규칙을 만들어 통일성을 얻기 위한 프레임워크 개발

>
### Framework
: Spring


<br><br>


# HTTP Client-Server 구조



#### Tomcat 연동

![](https://velog.velcdn.com/images/ramu/post/0b9fa78f-f2bb-4b25-a6f9-72e7918d7f6d/image.png)![](https://velog.velcdn.com/images/ramu/post/8c122055-1773-4ae8-86cf-2c220f954106/image.png)![](https://velog.velcdn.com/images/ramu/post/adb2285a-21e9-4d3f-a804-187cd8564ce3/image.png)


## Request
1) Web Client 측면
>
Request URL : http://localhost:8080/path/file?_______
			  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;프로토콜&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;IP   &nbsp;&nbsp;&nbsp;  포트번호
?___ : Query String (?key1=value1&key2=value2&key3=value3)


2) Web Server 측면
>
### HTTP Request Message
- Request Line: <strong>&lt;HTTP Method&gt; &lt;URL&gt; HTTP/1.1</strong>
- Request Header
  - Client의 IP
  - 사용언어 : ko(Acomp-language)
  - content-type
- Request Body: Query String의 정보


- HTTP Method : Client가 Server로 Request를 보내는 방식)

<br>


## Response
>
HTTP Response Message
- Response Line(status) : HTTP/1.1(Protocol 버전) 200(status code) OK(status 설명)
- Response Header: Message size, 데이터 타입 등 Response body에 관한 정보
  - Encoding
  - Content-type : MIME(HTTP, image, video 등..)
  - body size
  - Server description
- Response Body
  - Request한 파일을 문자열로 변환하여 브라우저에게 전달 ▶ 브라우저가 Response Body를 parsing하여 rendering
  
<br><br>

# Dynamic web project
- Project 이름 : eclipse에서 project를 식별하기 위한 이름
- context root : 우리 project가 client에 의해 지칭되는 이름 (우리 project의 web상에서 사용되는 논리적인 이름)

![](https://velog.velcdn.com/images/ramu/post/c5da22ad-353b-4797-a210-e74113a7dfb1/image.png)![](https://velog.velcdn.com/images/ramu/post/450dae48-8de2-441b-981c-85b5da2deeae/image.png)

-  project를 생성하고 코드 구현
    - Web Server에게 우리 project의 존재를 알려주어야 함 ▶ Configured
    - Web Server를 통해서 우리 Project를 Web에 Deploy
    
![](https://velog.velcdn.com/images/ramu/post/499f1fe4-8523-473f-8e03-6a37420b2d32/image.png)

<br>

## Browser에서 URL을 이용해 Request를 보냄
> http://localhost:8080/html/index.html
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;context root 요청 resource(없으면 자동으로 index.html)

![](https://velog.velcdn.com/images/ramu/post/89b9c32a-1754-4eb1-a159-06e498249824/image.png)![](https://velog.velcdn.com/images/ramu/post/29e105de-01da-4091-82ef-764f759978c4/image.png)

<br>

## 간단한 static web application 구현
- HTML (태그, 속성) ▶ Form (사용자 입력 양식) : Client가 Server에 Data를 전달할 목적으로 사용
- CSS
- Javascript

![](https://velog.velcdn.com/images/ramu/post/67a7e833-23c7-4b44-8ed5-d41d4ac8c8e8/image.png)![](https://velog.velcdn.com/images/ramu/post/f7207ef0-f04b-49dc-94e9-d5bdd85fc1f6/image.png)


<br><br>


# Client ▶ Server
### &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Request
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;사용자 데이터를 포함

<br>

## Request Method
### "GET"
>: Query String 이용

- Browser 주소창에 URL 입력
- Hypertext(링크)를 이용해서 Request
- Form tag 이용 ▶ method가 GET인 경우 form을 이용해 request

<br>

### "POST"
>: Query String을 사용하지 않고 request header에 데이터 포함

- Form tag 이용 ▶ method가 POST인 경우 form을 이용해 request



#### Query String
- 장점 : 간단
- 단점 : 
    - URL에 데이터가 노출 (보안)
    - 대량 데이터 전송 불가능

<br><br>

# Dynamic Web <span style="color: blue">(Servlet)</span>
![](https://velog.velcdn.com/images/ramu/post/bb28c30b-f8a4-48f4-a1a5-af7c08e06f3a/image.png)![](https://velog.velcdn.com/images/ramu/post/4f697e91-028b-45f1-b526-bb90f9ca5e61/image.png)![](https://velog.velcdn.com/images/ramu/post/79356cd5-6054-44a3-952d-de700c772d8d/image.png)

- URL mapping : Client가 Server Program(Servlet)을 식별할 때 사용하는 이름
![](https://velog.velcdn.com/images/ramu/post/72785c52-486f-4dbb-a44a-399be1a8a871/image.png)

![](https://velog.velcdn.com/images/ramu/post/18e1d8de-9973-443a-9937-d78873b8df59/image.png)


<br><br><br>


# Servlet 작동 원리
1) Web Client(Browser)가 Web Server(HTTP Server)에게 Request(Servlet 호출)
2) Web Server는 Web Container(Servlet Container[Servlet Engine])에게 Servlet 요청
- Servlet 요청은 Request 객체로 만들어져 Servlet Container로 전달됨
- Ex. /hello

3) Web Container 내에 요청된 Servlet 객체가 있는지 확인 (Container 내에 객체로 저장됨)
4) 해당 Servlet이 없으면 Servlet 객체를 만들 수 있는 Class가 있는지 확인
5) Thread가 생성됨
6) Thread는 Request, Response 생성해 service()에 전달하여 호출
- service() : doGet(), doPost()

Servlet은 Thread의 공용객체임

[그림 11]

<br><br>


![](https://velog.velcdn.com/images/ramu/post/e85fe22b-aa2e-4d93-9dab-f70b90a969b6/image.png)![](https://velog.velcdn.com/images/ramu/post/91d111d1-be1f-4d32-aa5f-7de264cae343/image.png)


## Request 처리 방법
![](https://velog.velcdn.com/images/ramu/post/32f4d5d0-4e24-4e76-9d29-e0e0fc9cf28a/image.png)![](https://velog.velcdn.com/images/ramu/post/6534aa60-e16b-4310-abd3-315ce1a8f189/image.png)

- HTML의 &lt;input&gt; 태그의 'name' 속성이 parameter(key)가 된다.
- 입력을 받을 때 사용되는 Stream의 encoding : ISO-8859-1
한글 데이터를 전달받으려면 데이터 가공 필요

>
#### 1) GET 방식 : Tomcat의 InputStream Encoding 변경![](https://velog.velcdn.com/images/ramu/post/6326f35b-40e7-40c1-9942-79b92a85cf23/image.png)
#### 2) POST 방식 : ```request.setCharacterEncoding("EUC-KR");```


<br><br>

# Servlet의 동작
## 문제점

- Layered Architecture의 적용 필요 ▶ MVC Pattern
- Servlet간의 데이터 공유 방법 없음 (하나의 Servlet이 처리한 결과를 다른 Servlet에서 사용할 방법이 없음)
- 결과에 대한 출력의 어려움 (Java code 내에서 HTML을 포함시켜야 함) 
▶ JSP, Front-end의 자체 처리(json) 
- HTTML Protocol은 <strong style="color: red">Stateless protocol</strong> : Client의 행적을 지속적으로 Tracking할 수 없음


## Servlet Context
[그림 13]
> 
모든 Servlet들이 공유하는 Map List 형태의 객체
Context Root 안에 Servlet Context 객체는 하나!


### Servlet 간의 데이터 공유


- #### A Servlet : "product"라는 key로 "냉장고"라는 데이터(value)를 Servlet Context에 저장

```
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	// 1. 입력
		
	// 2. 로직
	// Servlet Context 사용
	// ServletContext 객체를 얻어온다. (공유객체에 대한 Reference를 획득)
	ServletContext context = getServletContext();
		
	// ServletContext에 특정 정보를 저장
	context.setAttribute("product", "냉장고");
		
		
	// 3. 출력
}
```

- #### B Servlet : Servlet Context에서 "product"라는 key를 이용하여 얻은 data를 출력

```
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	// 1. 입력
	// 2. 로직
	ServletContext context = getServletContext();
	String product = (String)context.getAttribute("product");	// getAttribute(key)의 결과 Object로 반환되기 때문에 downcasting 필요
		
	// 3. 출력
	response.setContentType("text/html; charset=UTF-8");
	PrintWriter out = new PrintWriter(response.getOutputStream());
	out.println("얻어온 결과는 : " + product);
		
	out.close();
	
}
```
![](https://velog.velcdn.com/images/ramu/post/3b7f3c99-d2de-4786-9152-21f834c50695/image.png)![](https://velog.velcdn.com/images/ramu/post/0fe8f4e7-7bd1-42a6-bcc4-d9a976ec7d6a/image.png)


## HTTP Protocol : Stateless Protocol
> <h3>"Session 처리"를 통해 해결</h3>

[그림 14]

1) Web Client가 Web Server에게 Request
2) Web Server가 Servlet Container에게 Request
3) Client가 원하는 Servlet이 가지고 있는 메소드(doGet, doPost)를 Thread가 실행
4) 해당 메소드에서 session 처리
5) Servlet Container 내에 Session 객체가 생성됨 (map 형태의 저장 공간, Session id가 할당됨)
6) 처리된 결과와 Session id가 함께 Web Client에게 Response로 전달됨


- #### SessionTestServlet.java : session을 할당받아 session id 저장

```
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	// 1. 입력
	String id = request.getParameter("myID");
		
	// 2. Logic
	// 해당 Client에게 session을 할당하거나 할당된 session을 찾는다.
		
	HttpSession session = request.getSession();	// container로부터 session을 할당받음
	session.setAttribute("id", id);	// session에 id 저장
				
	// 3. 출력
}
```

- #### UseSessionServlet.java : session에 저장된 해당 Client의 session id를 출력

```
protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException {
	// 1. 입력
	// 2. Logic
	HttpSession session = request.getSession();
	String result = (String)session.getAttribute("id");	// session으로부터 client id를 가져온다.
		
	// 3. 출력
	response.setContentType("text/html; charset=UTF-8");
	PrintWriter out = new PrintWriter(response.getOutputStream());
	out.println("얻어온 결과는 : " + result);
		
	out.close();
}
```
![](https://velog.velcdn.com/images/ramu/post/b5378705-16a9-4901-8d62-45439516ad80/image.png)![](https://velog.velcdn.com/images/ramu/post/b1dbe0db-d9fb-4bbb-beba-d7287886dfee/image.png)
