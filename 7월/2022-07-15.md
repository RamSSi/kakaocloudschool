# Thread
<ol>
<li>Thread Class(Java에서 제공)를 상속한 class 작성</li>
<li>Runnable Interface 구현한 class 작성</li>
하여 Thread 생성
</ol>

<br>

### 상태전이도
1) Thread instance가 생성되면 New state
2) New state의 Thread에서 start()를 호출하면 Runnable state
3) Runnable state의 Thread가 Thread Scheduler의 선택을 받으면 run()을 호출하며 Running state
4) 해당 Thread의 run()이 종료되면 Dead state가 되어 Thread의 생명주기가 끝남
5) sleep()을 이용하여 Thread를 일시정지 시키면 Otherwise Blocked state
6) blocked 상태에서 sleep()의 시간이 모두 지나거나(sleep timeout) interrupt()가 호출되면 Runnable state (바로 Running state가 되는 것이 아님)
7) Running state에서 yield()를 호출하면 Runnable state로 전이되며 다른 Thread에게 자원을 양보

<br>
<br>

## Thread Control Method

### join() : 
- join()
- join(long s)

### sleep()과 차이
        - sleep() : static method (해당 method를 호출한 Thread)
        - join() : instance method (특정 Thread를 지정하여 사용 가능)

```
class ThreadExam07_1 extends Thread {
	@Override
	public void run() {
		for(int i = 0; i < 300; i++) {
			System.out.print("-");
		}
	}
}

class ThreadExam07_2 extends Thread {
	@Override
	public void run() {
		for(int i = 0; i < 300; i++) {
			System.out.print("|");
		}
	}
}

public class ThreadExam07 {
	public static void main(String[] args) {
		Thread t1 = new ThreadExam07_1();
		Thread t2 = new ThreadExam07_2();
		
		t1.start();
		t2.start();
		
		try {
			t1.join();	
			t2.join();
			// main Thread에서 실행했으므로 main Thread를 block시키고 t1, t2를 종료한 후 실행시켜라!
		
		} catch (Exception e) {
			
		}
		
		System.out.println("<<main>> 종료");
	}
}
```
<br>

# Thread의 동기화
공유자원의 동기화

### Critical Section (임계 영역)
- 특정 Thread가 이 영역에 진입하면 다른 Thread가 진입하지 못하는 영역 => lock(moniter, 임계 영역임을 설정, 표현)
- Java에서 "Lock"을 얻어 임계 영역을 설정하려면
<br> => synchronized keyword 사용
    - method 동기화
    - (👍) 동기화 block 생성

## "synchronized"를 이용해 공유 자원 보호
- Thread가 공유 자원에 대한 lock을 획득한 후 많은 시간을 사용
    - wait() : 획득한 lock을 반납하고 대기 상태가 됨
    - notify() : 대기 상태인 Thread가 실행될 수 있도록 block을 해제

# 

sleep, join => otherwize blocked
synchronized => blocked object's lock pool

1) <Thread 1>이 synchronized method를 호출했을 때 <Thread 2>, <Thread 3>이 똑같이 synchronized method를 호출하면 object's lock pool에 들어감
2) <Thread 1>의 method 실행이 끝나면 다음 <Thread>가 lock available(lock을 획득) 상태가 되면 Runnable이 아닌 Running state가 되어 synchronized method를 실행
3) Running state에서 wait()이 호출되면 Object's lock pool에 들어감
4) lock pool에 있던 Thread의 notify()가 호출되면 바로 Running state가 되는 것이 아니라 Runnable state가 됨


# 연습문제
1초마다 자신의 이름을 출력하는 Thread를 2개 생성
1) 이름을 출력할 때 교대로 출력
2)
3)


<br>
<br>
<br>

# Java 입출력
- IO (Input / Output)
- NIO (New I/O) - Java 4에서 등장, Java 7에서 정립

## Java I/O => Stream
- java.io Package로 제공됨 (입출력 관련 클래스들의 모임)

<br>
<br>

# 표준 입출력
### 표준 입력
 ▶ keyboard : System.in
### 표준 출력
 ▶ monitor : System.out

java i/o는 stream이라는 객체를 이용해서 입/출력 
처리

<br>

## Stream Instance
Java에서
- 특정 장치에서 data를 읽거나
- 특정 장치로 data를 보낼 때
사용하는 매개 객체

Java program과 File 사이에 stream이 통로 역할을 함

<br>
<br>
<br>

# Stream instance의 특징
1) 단방향
Stream을 생성할 때 Stream의 종류, 방향 결정
    - InputStream class : input을 받아들이는 연결 통로
    - OutputStream class : output을 내보내는 연결 통로

<br>

2) FIFO 구조 (First in, first out)
<br>Java program에서 File에 입력 data를 A, B, C, D 순서로 주면 같은 순서로 File에 입력됨
- 먼저 입출력된 데이터가 먼저 나옴

<br>

3) 결합 가능
<br>사용하기 쉬운 형태로 Stream들을 결합하여 새로운 Stream을 사용

<br>
<br>
<br>

# Stream 구분
|Input|Output|
|:---:|:---:|
|Byte|문자 Stream|

<br>

### Object Stream을 통해 객체(instance)도 전달할 수 있음
### 단, 모든 객체를 전달할 수 있는 것은 아님
▶ 만약 instance를 생성한 class가 Serializable interface를 구현하고 있으면 가능!!!

ex) String(java.lang), HashMap(java.util)