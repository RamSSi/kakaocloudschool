# JDBC (Java Database Connectivity)

### : Java Class와 interface의 집합

- DBMS(MySQL, Oracle, DB2 ... )가 각각 다르게 구현되어 있기 때문에 DB마다 사용 방법이 다름
- 프로그램 코드의 유지 보수, 재활용성 문제 발생 ▶ 공통의 interface 필요

<br>

## Java Program - DBMS
- JDBC interface : Java Program과 DBMS가 직접 연결되지 않고 interface를 통해 접근 ▶ 사용하는 DBMS에 따라 JDBC driver와 연결해줌
- ### JDBC driver : DBMS를 Java Program으로 조작할 수 있도록 해주는 Java Class
    - Database Vendor가 작성해서 배포
- Java program의 build path에 추가하여 Package 사용
![](https://velog.velcdn.com/images/ramu/post/e0df5097-6b2b-44a2-b8dc-6326ce9cad85/image.png)

![](https://velog.velcdn.com/images/ramu/post/69adcbac-5ea1-45b5-883d-b6504ac41166/image.png)

<br><br>

# JDBC 연결
## 1) JDBC driver loading 작업 : 사용하려는 Database에 맞는 driver class를 등록
- 🌟'Class'라는 class 사용
- DriverManager class의 register method 사용

<br>

## 2) DBMS와 연결 (실제로 데이터베이스 연결)
- 연결 성공 ▶ Connection 객체 반환 (DB에 접속 가능)
- 데이터베이스에서는 Session이 만들어짐
- 연결 통로를 만들어 자바 프로그램이 데이터베이스에 접근할 수 있게 해줌
- Load(부하)가 큰 작업
- 다 사용한 후 반드시 자원을 해제 (Close)
    - 연결할 수 있는 세션의 수가 정해져 있음
    - Database의 session이 종료될 수 있도록 처리

#### Jdbc URL : 문자열 객체, 어떤 Database session과 연결할 것인지에 대한 모든 정보가 담겨있음
- JDBC URL, ID, pw를 이용하여 connection을 생성

<br>

## 3) Stataement를 생성
- 일반 statement
- preparedStatement : 일반 statement 개량형

-> SQL 구문 실행
- callableStatement : SQL의 stored procedure 호출 가능

<br>

## 4) Query 실행
statement를 이용해 SQL Query를 DBMS에 전달하여 실행
- execute() : 동적으로 SQL이 변하는 경우 사용
- executeQuery() : SELECT
- executeUpdate() : INSERT, UPDATE, DELETE ▶ INT 반환 (영향을 받은 row(행)의 수)

#### ResultSet : 쿼리 실행 결과를 반환받는 객체

<br>

## 5) 결과 처리 (ResultSet)
```
ResultSet rs = pstmt.executeQuery();
```
- rs에 들어오는 값 : 결과 Record의 집합
- ```rs.next()``` : 다음 row로 이동하는 메서드 
    - return 값 : boolean (다음 행으로 이동 - True, 이동할 행 없음 - False)
- ```rs.get<<Type>>("field name" 또는 field column index)``` : 여러가지 type의 Database record의 data를 원하는 type으로 가져올 수 있음 
    - ex. ```rs.getString("name")```
    - ex. ```rs.getString(2)```
- 기본 ResultSet은 이전 행으로 돌아갈 수 없음 (ResultSet과 DB가 연동되지 않음)
    - Scrollable Cursor : 원하는 위치로 이동할 수 있음 (DB와 완전히 연결이 되어야 하기 때문에 부하가 큼)

- ```rs.set<<Type>>(IN Parameter의 index, 대입할 값)```
    - ex. ```rs.setString(0, "KBS")```
    
<br><br><br>

# Connection Pool
### 동시에 많은 사용자에 대해 Database 처리를 제공하려면?
- 하나의 Database 연결 객체인 Connection 공유??? 불가능 (Transaction 문제)
 #### Pooling 기법 사용
 1) 속도 향상
 2) 자원의 효율성 향상
 3) Connection 수 제어 가능 (가능한 Connection의 수를 지정하여 나머지 Connection 요구는 대기)
 
 - Connection Pool을 만드는 것은 매우 어려움(복잡한 구조)
 - Library 이용 
    - 무료 : Apache connection DBCP
	![](https://velog.velcdn.com/images/ramu/post/bc7e1261-189c-429a-a149-58b433e0dd40/image.png)

<br><br><br>
# Layered Architecture
- Presentation Layer : 입출력과 관련된 계층 <strong> > View</strong> ex. javafx
- Business Logic Layer : Logic 처리, 연산 => 결과를 Presentation Layer로 전달 <strong>> Service</strong>
- Persistence Layer : Business Layer에서 요구하는 DB 관련 Logic에 대해 Database를 직접 처리하는 계층 <strong>> DAO(Data Access Object</strong> 
- Database Layer : Database가 존재하는 계층 <strong>> </strong>

#### 각각의 Layer에서 나타나는 변화가 인접 Layer에 영향을 미치면 안되고, 떨어져있는 Layer와 아무런 관련이 없어야 한다.
#### => MVC : Layered Architecture를 잘 표현

DTO (Data Transfer Object) : 데이터의 규격화
VO (Value Object), DO ( Domain Object), Entity, Been??